//----------------------------------------------------------------------------------------------------------------------
// File: BryptIdentifier.cpp
// Description:
//----------------------------------------------------------------------------------------------------------------------
#include "BryptIdentifier.hpp"
#include "ReservedIdentifiers.hpp"
#include "Utilities/Base58.hpp"
//----------------------------------------------------------------------------------------------------------------------
#include <algorithm>
#include <array>
#include <cassert>
#include <cstdint>
#include <memory>
#include <vector>
//----------------------------------------------------------------------------------------------------------------------
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
//----------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------
namespace {
namespace local {
//----------------------------------------------------------------------------------------------------------------------

using Buffer = std::vector<std::uint8_t>;
using DigestContext = std::unique_ptr<EVP_MD_CTX, decltype(&EVP_MD_CTX_free)>;

Buffer GenerateIdentifier(DigestContext const& upDigest);
std::string ToExternalIdentifier(DigestContext const& upDigest, Node::Internal::Identifier const& identifier);
std::string ToExternalIdentifier(DigestContext const& upDigest, Buffer const& identifier);
bool Shake128(EVP_MD_CTX* pDigest, Buffer const& source, Buffer& destination, std::uint32_t length);

//----------------------------------------------------------------------------------------------------------------------
} // local namespace
} // namespace
//----------------------------------------------------------------------------------------------------------------------

std::string Node::GenerateIdentifier()
{
    //Setup the hashing context to process the randomly generated bytes
    local::DigestContext upDigestContext(EVP_MD_CTX_new(), &EVP_MD_CTX_free);
	if (ERR_get_error() != 0 || upDigestContext == nullptr) { return {}; }

    local::Buffer const identifier = local::GenerateIdentifier(upDigestContext);
    return local::ToExternalIdentifier(upDigestContext, identifier);
}

//----------------------------------------------------------------------------------------------------------------------

std::optional<Node::Internal::Identifier> Node::ToInternalIdentifier(local::Buffer const& buffer)
{
    if (buffer.size() != Identifier::PayloadBytes) { return {}; }

    Node::Internal::Identifier identifier = {};
    boost::multiprecision::import_bits(identifier, buffer.begin(), buffer.end());
    return identifier;
}

//----------------------------------------------------------------------------------------------------------------------

std::optional<Node::Internal::Identifier> Node::ToInternalIdentifier(std::string_view identifier)
{
    // Verify the identifer's metadata works with this version of the Brypt node
    if (auto const result = identifier.compare(0, Identifier::Metadata.size(), Identifier::Metadata); result != 0) {
        return {};
    }

    auto const seperatorPosition = identifier.find_first_of(Identifier::MetadataSeperator);
    assert(seperatorPosition != std::string::npos); // If the metadata was not found, how did we get here?

    std::string_view const payload = identifier.substr(seperatorPosition + 1, identifier.size() - seperatorPosition);

    local::Buffer buffer = Base58::Decode(payload);
    local::Buffer identifierBytes(buffer.begin(), buffer.end() - Identifier::ChecksumBytes);
    local::Buffer receivedChecksumBytes(buffer.end() - Identifier::ChecksumBytes, buffer.end());

    //Setup the hashing context to process the randomly generated bytes
    local::DigestContext upDigestContext(EVP_MD_CTX_new(), &EVP_MD_CTX_free);
	if (ERR_get_error() != 0 || upDigestContext == nullptr) { return {}; }

    local::Buffer generatedChecksumBytes(Identifier::ChecksumBytes, 0x00);
    local::Shake128(upDigestContext.get(), identifierBytes, generatedChecksumBytes, Identifier::ChecksumBytes);
    if(generatedChecksumBytes.empty()) { return {}; }

    auto const result = CRYPTO_memcmp(
        generatedChecksumBytes.data(), receivedChecksumBytes.data(), generatedChecksumBytes.size());
	if (result != 0) { return {}; }
    
    return ToInternalIdentifier(identifierBytes);
}

//----------------------------------------------------------------------------------------------------------------------

std::optional<Node::External::Identifier> Node::ToExternalIdentifier(Internal::Identifier const& identifier)
{
    local::DigestContext upDigestContext(EVP_MD_CTX_new(), &EVP_MD_CTX_free);
    if (ERR_get_error() != 0 || upDigestContext == nullptr) { return {}; }

    return local::ToExternalIdentifier(upDigestContext, identifier);
}

//----------------------------------------------------------------------------------------------------------------------

std::optional<Node::External::Identifier> Node::ToExternalIdentifier(local::Buffer const& identifier)
{
    local::DigestContext upDigestContext(EVP_MD_CTX_new(), &EVP_MD_CTX_free);
    if (ERR_get_error() != 0 || upDigestContext == nullptr) { return {}; }

    return local::ToExternalIdentifier(upDigestContext, identifier);
}

//----------------------------------------------------------------------------------------------------------------------

Node::Identifier::Identifier()
    : m_internal(Internal::InvalidIdentifier)
    , m_network(External::InvalidIdentifier)
    , m_valid(false)
{
}

//----------------------------------------------------------------------------------------------------------------------

Node::Identifier::Identifier(Internal::Identifier const& identifier)
    : m_internal(Internal::InvalidIdentifier)
    , m_network(External::InvalidIdentifier)
    , m_valid(false)
{
    FromInternalIdentifier(identifier);
}

//----------------------------------------------------------------------------------------------------------------------

Node::Identifier::Identifier(std::string_view identifier)
    : m_internal(Internal::InvalidIdentifier)
    , m_network(External::InvalidIdentifier)
    , m_valid(false)
{
    FromExternalIdentifier(identifier);
}

//----------------------------------------------------------------------------------------------------------------------

Node::Identifier::Identifier(local::Buffer const& buffer, BufferContentType type)
    : m_internal(Internal::InvalidIdentifier)
    , m_network(External::InvalidIdentifier)
    , m_valid(false)
{
    switch (type) {
        case BufferContentType::Internal: {
            if (auto const optIdentifier = ToInternalIdentifier(buffer); optIdentifier) {
                FromInternalIdentifier(*optIdentifier);
            }
        } break;
        case BufferContentType::Network: {
            auto const pData = reinterpret_cast<char const*>(buffer.data());
            FromExternalIdentifier({ pData, buffer.size() });
        } break;
        default: assert(false); break;
    }
}

//----------------------------------------------------------------------------------------------------------------------

bool Node::Identifier::operator<(Identifier const& other) const
{
    if (m_valid != other.m_valid) { return m_valid < other.m_valid; }
    return m_internal < other.m_internal;
}

//----------------------------------------------------------------------------------------------------------------------
 
bool Node::Identifier::operator==(Identifier const& other) const
{
    if (!m_valid && !other.m_valid) { return false; } // Invalid identifiers don't compare equal
    return m_internal == other.m_internal;
}

//----------------------------------------------------------------------------------------------------------------------

bool Node::Identifier::operator!=(Identifier const& other) const
{
    return !operator==(other);
}

//----------------------------------------------------------------------------------------------------------------------

Node::Identifier::operator Node::Internal::Identifier const&() const
{
    return m_internal;
}

//----------------------------------------------------------------------------------------------------------------------

Node::Identifier::operator Node::External::Identifier const&() const
{
    return m_network;
}

//----------------------------------------------------------------------------------------------------------------------

Node::Internal::Identifier const& Node::Identifier::ToInternal() const
{
    return m_internal;
}

//----------------------------------------------------------------------------------------------------------------------

Node::External::Identifier const& Node::Identifier::ToExternal() const
{
    return m_network;
}

//----------------------------------------------------------------------------------------------------------------------

std::size_t Node::Identifier::Size() const
{
    return m_network.size();
}

//----------------------------------------------------------------------------------------------------------------------

bool Node::Identifier::IsValid() const
{
    return m_valid;
}

//----------------------------------------------------------------------------------------------------------------------

void Node::Identifier::FromInternalIdentifier(Internal::Identifier const& identifier)
{
    if (!Node::IsIdentifierAllowed(identifier)) { return; }

    if (auto const optNetworkRepresentation = ToExternalIdentifier(identifier); optNetworkRepresentation) {
        m_internal = identifier;
        m_network = *optNetworkRepresentation;
        m_valid = true;
        assert(m_internal == ToInternalIdentifier(m_network));
    }
}

//----------------------------------------------------------------------------------------------------------------------

void Node::Identifier::FromExternalIdentifier(std::string_view identifier)
{
    if (!Node::IsIdentifierAllowed(identifier)) { return; }

    if (auto const optInternalRepresentation = ToInternalIdentifier(identifier); optInternalRepresentation) {
        m_internal = *optInternalRepresentation;
        m_network = identifier;
        m_valid = true;
        assert(m_internal == ToInternalIdentifier(m_network));
    }
}

//----------------------------------------------------------------------------------------------------------------------

std::ostream& Node::operator<<(
    std::ostream& stream, Node::Identifier const& identifier)
{
    stream << identifier.m_network;
    return stream;
}

//----------------------------------------------------------------------------------------------------------------------

std::stringstream& Node::operator<<(
    std::stringstream& stream, Node::Identifier const& identifier)
{
    stream << identifier.m_network;
    return stream;
}

//----------------------------------------------------------------------------------------------------------------------

std::stringstream& Node::operator<<(
    std::stringstream& stream, Node::SharedIdentifier const& spIdentifier)
{
    if (!spIdentifier) {
        stream << "[Unknown Identifier]";
    } else {
        stream << spIdentifier->m_network;
    }
    return stream;
}

//----------------------------------------------------------------------------------------------------------------------

local::Buffer local::GenerateIdentifier(DigestContext const& upDigest)
{
    local::Buffer identifier(Node::Identifier::PayloadBytes, 0x00);

    do {
        // Get 128 random bits to generate the brypt identifier
        local::Buffer source(Node::Identifier::PayloadBytes, 0x00);
        if (!RAND_bytes(source.data(), Node::Identifier::PayloadBytes) || ERR_get_error() != 0) { return {}; }

        // Hash the random bytes using Shake128 into a buffer. The goal here is to have  a sufficiently random identifer
        // with low likely-hood of collision on the Brypt network. 
        local::Shake128(upDigest.get(), source, identifier, Node::Identifier::PayloadBytes);
        if(identifier.empty()) { return {}; }
    } while(Node::IsIdentifierReserved(identifier));

    return identifier;
}

//----------------------------------------------------------------------------------------------------------------------

std::string local::ToExternalIdentifier(DigestContext const& upDigest, Node::Internal::Identifier const& identifier)
{
    Buffer bytes;
    boost::multiprecision::export_bits(identifier, std::back_inserter(bytes), 8);

    Buffer buffer(Node::Identifier::PayloadBytes - bytes.size(), 0x00);
    std::copy(bytes.begin(), bytes.end(), std::back_inserter(buffer));
    
    return local::ToExternalIdentifier(upDigest, buffer);
}

//----------------------------------------------------------------------------------------------------------------------

std::string local::ToExternalIdentifier(DigestContext const& upDigest, local::Buffer const& identifier)
{
    Buffer buffer(identifier);

    // Generate a simple checksum of the identifier. This is not for cryptographic security and used to verify the 
    // correct identifier has been received. 
    Buffer checksum(Node::Identifier::ChecksumBytes, 0x00);
    Shake128(upDigest.get(), buffer, checksum, Node::Identifier::ChecksumBytes);
    if(checksum.empty()) { return {}; }
    
    buffer.insert(buffer.end(), checksum.begin(), checksum.end());

    std::string payload = {};
    payload.append(Node::Identifier::Metadata); // Prefix the identifier with brypt information
    Base58::Encode(buffer, payload); // Encode for safe network transfer and a human readible identifier. 

    return payload;
}

//----------------------------------------------------------------------------------------------------------------------

bool local::Shake128(EVP_MD_CTX* pDigest, Buffer const& source, Buffer& destination, std::uint32_t length)
{
    if (EVP_DigestInit_ex(pDigest, EVP_shake128(), nullptr) != 1 || ERR_get_error() != 0) {
        destination.clear();
        return false;
    }

    if (EVP_DigestUpdate(pDigest, source.data(), source.size()) != 1 || ERR_get_error() != 0) {
        destination.clear();
        return false;
    }

    if (EVP_DigestFinalXOF(pDigest, destination.data(), length) != 1 || ERR_get_error() != 0) {
        destination.clear();
        return false;
    }

    return true;
}

//----------------------------------------------------------------------------------------------------------------------
